 # 数据库同步 | 封锁协议与锁

 ## 事务的ACID

 * A  原子性  Atomicity  事务的提交和回滚
 * C  一致性  Consistent  不破坏数据库的完整性约束
 * I  隔离性  Isolation  每个事务只能查看数据修改前和修改后的状态
 * D  持久性  Durability  所做的增删改查具有持久性

 ## 数据库并发的四类错误

 ### 丢失修改

> 两个事务同时修改同一字段，会丢失其中一个修改

 ### 脏读

> 事务A读了事务B修改的数据，但事务B回滚，事务A读取了脏数据

 ### 不可重复读(实际包括幻读)

> 事务A读数据，事务B修改，事务A再读则与上次不一样

 ### 幻读

>* 事务A读数据，事务B删除了一些，某些记录消失了
>* 事务A读数据，事务B插入了一些，某些记录消失了

### 不可重复读侧重于 读-读  |  幻读侧重于 读-写
### 提交 commit | 回滚 callback

## 事务隔离级别 | 四层封锁协议

### 排他锁 x锁 | 共享锁 s锁

>* 排他锁：写锁   加锁后其他事务不能施加任何锁
>* 共享锁：读锁   加锁后其他事务只能施加共享锁

### A 未授权读取 Read uncommited 允许脏读，不许丢失修改
* 一级封锁协议：施加排他锁
### B 授权读取 Read commited 允许不可重复读，不需脏读和丢失修改
* 二级封锁协议：施加排他锁和瞬间共享锁
### C 可重复读 Repaetable Read 禁止不可重复读、脏读、丢失修改，可能出现幻读
* 三级封锁协议：施加排他锁和共享锁
### D 序列化 | 施加表锁
* 事务序列化，即类似单线程

> 锁只对申请加锁的事务有效，例如共享锁和排他锁

## 乐观锁和悲观锁

### 悲观锁  预计会发生冲突
> 利用以上封锁协议进行封锁，行锁或者表锁
### 乐观锁  预计不会发生冲突
>```
> 每次存数据设置时间戳或版本号
> 提交数据时检测时间戳或版本号，若无变化则提交(commit)，否则回滚(callback)
>```

## 死锁
* 互斥条件:资源独占
* 不可剥夺条件：进程资源未使用完毕不能被其他进程剥夺
* 请求和保持条件:进程可以保持已分配的资源，继续占用已分配的资源
* 循环等待条件:p1请求p2的资源，p2请求p3的资源，...pn请求p1的资源 循环队列
